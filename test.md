[Вопросы для собеседования](README.md)

# Тестирование
+ [Что такое _«модульное тестирование»_?](#Что-такое-модульное-тестирование)
+ [Что такое _«интеграционное тестирование»_?](#Что-такое-интеграционное-тестирование)
+ [Чем интеграционное тестирование отличается от модульного?](#Чем-интеграционное-тестирование-отличается-от-модульного)
+ [Какие существуют виды тестовых объектов?](#Какие-существуют-виды-тестовых-объектов)
+ [Чем _stub_ отличается от _mock_?](#Чем-stub-отличается-от-mock)
+ [Что такое _«фикстуры»_?](#Что-такое-фикстуры)
+ [Какие аннотации фикстур существуют в JUnit?](#Какие-аннотации-фикстур-существуют-в-junit)
+ [Для чего в JUnit используется аннотация `@Ignore`?](#Для-чего-в-junit-используется-аннотация-ignore)


## Пирамида тестирования
Изобрёл Mike Cohn в своей книге Succeeding with Agile. В оригинале содержала три прослойки - Unit тесты, Service тесты и UI тесты.

Была призвана как визуальная метафора для понимания, что более изолированные тесты более быстрые и «недорогие», поэтому использовать в приложении их нужно больше, чем более медленных service тестов, которых в свою очередь нужно использовать больше, чем ещё более медленных UI тестов.

В наше время количество видов тестов существенно выросло, и из пирамиды лучше просто вынести два правила:
+	писать тесты нужно на разных уровнях гранулярности;
+	чем на более высоком уровне мы находимся, тем меньше тестов должно быть.

[к оглавлению](#Тестирование)

## Какие есть разновидности тестов?

+ __Unit testing__
+ __Integration testing__
+ __Acceptance testing__
+ __UI testing__

[к оглавлению](#Тестирование)

## TDD, BDD, DDT 

+	__Test-Driven Development (TDD)
Методика разработки через тестирование (TDD) заключается в организации автоматического тестирования разрабатываемых приложений путем написания модульных, интеграционных и функциональных тестов, определяющих требования к коду непосредственно перед написанием этого самого кода. Сначала пишется тест, который проверяет корректность работы еще ненаписанного программного кода. Этот тест, разумеется, не проходит. После этого разработчик пишет код, который выполняет действия, требуемые для прохождения теста. После того, как тест успешно пройден, по необходимости осуществляется доработка написанного кода, причём под контролем прохождения тестов.

Разработка через тестирование предлагает больше, чем просто проверку корректности, она также влияет на дизайн программы. Изначально сфокусировавшись на тестах, проще представить, какая функциональность необходима пользователю. Таким образом, разработчик продумывает детали интерфейса до реализации. Все это помогает сократить время на разработку и отладку программы.

Однако стоит отметить, что разработку через тестирование сложно применять в тех случаях, когда для тестирования необходимо прохождение функциональных тестов. Примерами может быть: разработка интерфейсов пользователя, программ, работающих с базами данных, а также того, что зависит от специфической конфигурации сети. Разработка через тестирование не предполагает большого объёма работы по тестированию такого рода вещей. Она сосредотачивается на тестировании отдельно взятых модулей, используя mock-объекты (заглушки) для представления внешнего мира.

+	__Behavior-Driven Design (BDD)
BDD — разработка, основанная на поведении. BDD, это разновидность TDD, разница в том, что BDD ориентирован на поведение сущности, которую вы тестируете, в то время как в TDD весь фокус идет на сам код. Суть BDD — в описании системы архитектуры приложения в терминах эксперта предметной области, а не программиста, что позволяет ускорить процесс получения обратной связи и убрать традиционные языковые барьеры между создателями ПО и его пользователями.

Тесты пишутся на простом языке управляемой поведением разработки (BDD) в стиле Given, When, Then (условия, операция, результат), которой понятен любому пользователю. Затем контрольные тесты записываются в файлы функций, охватывающие один или несколько сценариев тестирования. BDD-синтаксис Given, When, Then интуитивно понятен. 

+	__Data Driven Testing (DDT)
Рассмотрим классическую ситуацию - тестирование страницы логина на сайт. Данные подаваемые на вход могут быть различные: это и неверные username и password, и запрещенные символы, и просто поля могут оставить пустыми. Что же делать автоматизатору в таком случае? Писать отдельные тест для каждого возможного ввода? Чтобы избежать подобных проблем существует следующий подход к тестированию, который называется Data Driven Testing (DDT). DDT позволяет данные хранить отдельно от тестов. Наш написанный тест, каждый раз читает данные из хранилища (Excel, CSV или в база данных) и выполняется, используя их. Продолжается это до тех пор пока тесты не будут запущены со всеми данными.

+	__Keyword Driven Testing (KDT)
Это подход, в котором используются ключевые слова, описывающие набор действий, необходимых для выполнения определенного шага тестового сценария. Сперва определяется набор ключевых слов, а затем ассоциируется действие (или функция), связанное с этим ключевым словом. Т.е. каждый шаг теста, такой как открытие или закрытие браузера, щелчок мышью, нажатие клавиши и т.д., описывается ключевым словом, таким как «открыть» (openbrowser), «нажать» (click).

При KDT тестировании вы можете создавать простые функциональные тесты на ранних этапах разработки, тестируя приложение по частям. Самый простой способ составить KDT тест, записать его. После записи тест можно изменить и настроить в соответствии с требованием. Когда тест-кейсы выполняются, ключевые слова интерпретируются тестовой библиотекой.

[к оглавлению](#Тестирование)

## Что такое мутационное тестирование?

Юнит тесты помогают нам удостовериться, что код работает так, как мы этого хотим. Одной из метрик тестов является процент покрытия строк кода (Line Code Coverage).
Но насколько корректен данный показатель? Имеет ли он практический смысл и можем ли мы ему доверять? Ведь если мы удалим все assert строки из тестов, или просто заменим их на assertSame(1, 1), то по-прежнему будем иметь 100% Code Coverage, при этом тесты ровным счетом не будут тестировать ничего. Насколько вы уверены в своих тестах? Покрывают ли они все ветки выполнения ваших функций? Тестируют ли они вообще хоть что-нибудь?

Ответ на этот вопрос даёт мутационное тестирование. Мутационное тестирование — это метод тестирования ПО, основанный на всевозможных изменениях исходного кода и проверке реакции на эти изменения набора автоматических тестов. Если тесты после изменения кода успешно выполняются, значит либо код не покрыт тестами, либо написанные тесты неэффективны. Критерий, определяющий эффективность набора автоматических тестов, называется Mutation Score Indicator (MSI).

Введем некоторые понятия из теории мутационного тестирования:

+ Одно изменение исходного кода будем называется Мутацией. Например, изменение бинарного оператора "+" на бинарный "-" является мутацией кода.

+ Результатом мутации является Мутант — то есть это новый мутированный исходный код.

+ Каждая мутация любого оператора в вашем коде (а их сотни) приводит к новому мутанту, для которого должны быть запущены тесты.

Итак, мутационное тестирование создает множество мутантов из вашего кода, для каждого из них запускает тесты и проверяет, выполнились они успешно или нет. Если тесты упали — значит всё хорошо, они отреагировали на изменение в коде и поймали ошибку. Такой мутант считается убитым (Killed mutant). Если тесты выполнились успешно после мутирования — это говорит о том, что либо ваш код не покрыт в этом месте тестами вовсе, либо тесты, покрывающие мутированную строку, неэффективны и в недостаточной степени тестируют данный участок кода. Такой мутант называется выжившим (Survived, Escaped Mutant). Важно понимать, что мутационное тестирование это не хаотичное преобразование кода, а абсолютно предсказуемый и понятный процесс, который, при наличии одинаковых входных мутационных операторов, всегда выдает один и тот же список мутаций и результирующие метрики на одинаковом тестируемом исходном коде.

[к оглавлению](#Тестирование)

## Что такое _«модульное тестирование»_?
__Модульное/компонентное тестирование (unit testing)__ - процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

Модульные тесты можно условно поделить на две группы: 

+ _тесты состояния (state based)_, проверяющие что вызываемый метод объекта отработал корректно, проверяя состояние тестируемого объекта после вызова метода.

+ _тесты взаимодействия (interaction tests)_, в которых тестируемый объект производит манипуляции с другими объектами. Применяются, когда требуется удостовериться, что тестируемый объект корректно взаимодействует с другими объектами.

[к оглавлению](#Тестирование)

## Что такое _«интеграционное тестирование»_?
__Интеграционное тестирование (integration testing)__ — это тестирование, проверяющие работоспособность двух или более модулей системы в совокупности — то есть нескольких объектов как единого блока. В тестах взаимодействия же тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.

[к оглавлению](#Тестирование)

## Чем интеграционное тестирование отличается от модульного?
С технологической точки зрения интеграционное тестирование является количественным развитием модульного, поскольку так же, как и модульное тестирование, оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки на месте отсутствующих модулей. Основная разница между модульным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа.

> Допустим, есть класс, который при определенных условиях взаимодействует с web-сервисом через зависимый объект. И нам надо проверить, что определенный метод зависимого объекта действительно вызывается. Если в качестве зависимого класса передать:

> + реальный класс, работающий с web-сервисом, то это будет интеграционное тестирование.

> + заглушку, то это будет тестирование состояния.

> + шпиона, а в конце теста проверить, что определенный метод зависимого объекта действительно был вызван, то это будет тест взаимодействия.

[к оглавлению](#Тестирование)

## Какие существуют виды тестовых объектов?
__пустышка (dummy)__ - объект, который обычно передается в тестируемый класс в качестве параметра, но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.

> Примером dummy-объектов являются new object(), null, «Ignored String» и т.д.

__фальшивка (fake object)__ применяется в основном для ускорения запуска ресурсоёмких тестов и является заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией. 

> Основные примеры — эмулятор базы данных (fake database) или фальшивый web-сервис.

__заглушка (test stub)__ используется для получения данных из внешней зависимости, подменяя её. При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее определённый результат.

> Тестируемый объект использует чтение из конфигурационного файла? Тогда передаем ему заглушку `ConfigFileStub` возвращающую тестовые строки конфигурации без обращения к файловой системе.

__шпион (test spy)__ - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из тестируемой системы, чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание параметров вызовов.

> Если существует необходимость проверки, что определённый метод тестируемого класса вызывался ровно 1 раз, то шпион - именно то, что нам нужно. 

__фикция (mock object)__ похож на _шпиона_, но обладает расширенной функциональностью, заранее заданными поведением и реакцией на вызовы.

[к оглавлению](#Тестирование)

## Чем _stub_ отличается от _mock_?
_stub_ используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на вызовы.

_mock_ использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и контролирует его.

[к оглавлению](#Тестирование)

## Что такое _«фикстуры»_?
__Фикстуры (fixtures)__ - состояние среды тестирования, которое требуется для успешного выполнения теста. Основная задача фикстур заключается в подготовке тестового окружения с заранее фиксированным/известным состоянием, чтобы гарантировать повторяемость процесса тестирования.

[к оглавлению](#Тестирование)

## Какие аннотации фикстур существуют в JUnit?

+ `@BeforeClass` - определяет код, который должен единожды выполниться перед запуском набора тестовых методов.
+ `@AfterClass` - код, выполняемый один раз после исполнения набора тестовых методов.
+ `@Before` - определяет код, который должен выполняться каждый раз перд запуском любого тестовым методом.
+ `@After` - код, выполняемый каждый раз после исполнения любого тестового метода.

[к оглавлению](#Тестирование)

## Для чего в JUnit используется аннотация `@Ignore`?
`@Ignore` указывает JUnit на необходимость пропустить данный тестовый метод.

[к оглавлению](#Тестирование)

# Источники
+ [Википедия](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения)
+ [Хабрахабр](https://habrahabr.ru/post/116372/)
+ [Интуит](http://www.intuit.ru/department/se/testing/5/2.html)

[Вопросы для собеседования](README.md)
